## Hash


### 二叉树

```text
红黑树是一种自平衡排序二叉树，树中每个节点的值，都大于或等于在它的左子树中的所有节点的值，
并且小于或等于在它的右子树中的所有节点的值，这确保红黑树运行时可以快速地在树中查找和定位的所需节点。
```
使用举例： TreeMap


### 平衡二叉树

```text
排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。

排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：
    若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
    若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
    它的左、右子树也分别为排序二叉树。
```

![图 1. 排序二叉树](https://www.ibm.com/developerworks/cn/java/j-lo-tree/image001.png)

对排序二叉树，若按中序遍历就可以得到由小到大的有序序列。如图 1 所示二叉树，中序遍历得：
{2，3，4，8，9，9，10，13，15，18}

创建排序二叉树的步骤，也就是不断地向排序二叉树添加节点的过程，向排序二叉树添加节点的步骤如下：

    以根节点当前节点开始搜索。
    拿新节点的值和当前节点的值比较。
    如果新节点的值更大，则以当前节点的右子节点作为新的当前节点；如果新节点的值更小，则以当前节点的左子节点作为新的当前节点。
    重复 2、3 两个步骤，直到搜索到合适的叶子节点为止。
    将新节点添加为第 4 步找到的叶子节点的子节点；如果新节点更大，则添加为右子节点；否则添加为左子节点。
#### 缺点

```tex
如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很差。
```




### 红黑树（对称二叉 B 树）

```text
红黑树是一种自平衡排序二叉树，树中每个节点的值，都大于或等于在它的左子树中的所有节点的值，
并且小于或等于在它的右子树中的所有节点的值，这确保红黑树运行时可以快速地在树中查找和定位的所需节点。
```
```tex
为了解决平衡二叉树的缺点，红黑树在原有的排序二叉树增加了如下几个要求：
Java 实现的红黑树
    性质 1：每个节点要么是红色，要么是黑色。
    性质 2：根节点永远是黑色的。
    性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。
    性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）
    性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点
上面的性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。
根据性质 5：红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度（black-height）”。

性质 4 则保证了从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍。假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 - 黑节点 - 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 - 红节点 - 黑节点 - 红节点 - 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，红黑树中最长路径就是一条红黑交替的路径。
```

![https://www.ibm.com/developerworks/cn/java/j-lo-tree/image006.png](https://www.ibm.com/developerworks/cn/java/j-lo-tree/image006.png)

#### 使用举例： TreeMap、 HashMap

