## Hash



### 
hash采用 16位 数组， 高低位各自16位二进制数值， 将高位右移16位，前面补充16个0；
然后将新的数值 与 旧值 进行 异或 运算。
### hashmap
以HashMap为例，16位数组，数组的下标相同， 使用链表连接 。每个Node 节点：key+hash+value+next  
tab[(n - 1) & hash]
查找或者插入步骤： 先根据HASH找到数组下标， 在一个链表找到对应的node。 
```text
为什么不安全？ node 存放在heap中，而操作put() 存在各自现场的操作数栈，多线程自然存在ABA问题。  
解决： 1. hashtable 在hashmap的put() 加上synchronize, 对整个map对象加锁，低效阻塞。
      2. concurrentHashMap 解决ABA问题，采用CAS方法，对数组的某个下标节点 先比较后交换，即只对这个tab加锁
      Segment段，即分段锁，数组->Segment数组， extends ReentrantLock

jdk1.8 改动： 在链表基础改成 元素>8则红黑树， 横向扩容， 加速链表上的检索速度 降低O(logN)
```


### 为什么使用^运算
hash 需要 均匀散列 在桶tab[key, value](数组) hashcode()是一个native , 采用异或运算, 0/1 概率更平均。
```text
<< : 左移运算符，num << 1,相当于num乘以2  低位补0
>> : 右移运算符，num >> 1,相当于num除以2  高位补0
>>> : 无符号右移，忽略符号位，空位都以0补齐
 % : 模运算 取余
^ :   位异或 第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为1，否则为0
 & : 与运算 第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0
 | :  或运算 第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0
 ~ : 非运算 操作数的第n位为1，那么结果的第n位为0，反之，也就是取反运算（一元操作符：只操作一个数）

```
#### & 运算
  0 0 1 1  
  0 1 0 1
------------  
  0 0 0 1    ->  0的概率是 75%； 1的概率是25%
  
#### | 运算
  0 0 1 1  
  0 1 0 1
------------
  0 1 1 1    ->  1的概率是 75%； 0的概率是25%
### ^ 运算
  0 0 1 1  
  0 1 0 1
------------
  0 1 1 0    ->  1的概率是 50%； 0的概率是50%